#!/bin/bash
#
# yesod test runner
#
# searched for "test files" at test/*_test.sh
#
# a test file can contain the follwing special function definitions:
#
#   setup:    run before _every_ test
#   teardown: run after _every_ test
#   test_*:   any functions prefixed with this are taken to be your
#             actual tests
#
# compiles the application and runs any test_* functions "as tests",
# meaning:
#
# stderr is silenced (unless --verbose) and stderr is collected in /tmp
# (use --tmp <dir> to override). after all tests finish, the failurs and
# collected stderr is reported.
#
###
usage() { echo 'runtests [ --verbose ] [ --tmp <dir> ]'; exit 1; }

# runs the function named by $1 as a test.  failures are tracked to be
# reported on after all tests have been run
run_test() { # {{{
  local test_function="$*" stdout

  $verbose && stdout='/dev/stdout' || stdout='/dev/null'

  type -p setup && setup

  if $test_function >"$stdout" 2>"$tmp/$test_function.errors"; then
    echo -n '.'
    rm -f "$tmp/$test_function.errors"
  else
    echo -n 'F'
    FAILURES+=( "$test_function" )
  fi

  type -p teardown && teardown
}
# }}}

# a test file can contain the follwing special function definitions:
#
#   setup:    run before _every_ test
#   teardown: run after _every_ test
#   test_*:   any functions prefixed with this are taken to be your
#             actual tests
#
# unset any existing definitions and source new ones from the file named
# by $1
source_test_file() { # {{{
  local test_file="$1" test_

  [[ -f "$test_file" ]] || return 1

  unset -f setup teardown

  while read -r test_; do
    unset -f test_ # unset any already-defined test_ functions
  done < <(set | sed '/^\(test_[^ ]*\) ()/!d; s//\1/g')

  source "$test_file" || return 1

  # read any newly defined test_ funcitons into a TESTS array
  read -r -d '\n' -a TESTS < <(set | sed '/^\(test_[^ ]*\) ()/!d; s//\1/g')
}
# }}}

# outputs a report of tests and failures
report() { # {{{
  local test_

  echo
  echo
  echo "Tests: ${#TESTS[@]}, Failures: ${#FAILURES[@]}."
  echo

  [[ ${#FAILURES[@]} -eq 0 ]] && return 0

  for test_ in ${FAILURES[@]}; do
    echo "Failure: $test_"
    echo 'details:'
    echo

    if [[ -f "$tmp/$test_.errors" ]]; then
      cat "$tmp/$test_.errors"
      rm  "$tmp/$test_.errors"
    else
      echo '<no stderr captured>'
    fi

    echo
  done

  return ${#FAILURES[@]}
}
# }}}

tmp='/tmp'
verbose=false

while [[ -n "$1" ]]; do
  case "$1" in
    -t|--tmp)     shift; tmp="$1" ;;
    -v|--verbose) verbose=true    ;;
    *)            usage           ;;
  esac
done

echo 'Compiling application...'
(
  set -e
  cabal clean
  cabal install
  cabal sdist
) &>/dev/null || { echo 'Failed.' >&2; exit 1; }

read -r pkg < <(find dist/ -type f -name '*.tar.gz' | sort -rV)
dir="$(basename "$pkg" .tar.gz)"

tar -xzf "$pkg"

echo 'Started'
for file in test/*_test.sh; do
  source_test_file "$file"

  cd "$dir"
  for test in "${TESTS[@]}"; do
    run_test $test
  done
  cd - >/dev/null
done

rm -rf "$dir"

report
